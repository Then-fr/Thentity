<?php

namespace Thentity;

use PDO;
/*

$config = require __DIR__ . '/thentity.config.php';

$dbConf = $config['db'];
$outputAbstract = $config['output']['abstract_dir'];
$outputConcrete = $config['output']['concrete_dir'];
$nsAbstract = $config['namespace']['abstract'];
$nsConcrete = $config['namespace']['concrete'];


try {
    $pdo = new PDO(
        "mysql:host={$dbConf['host']};dbname={$dbConf['name']};charset={$dbConf['charset']}",
        $dbConf['user'],
        $dbConf['pass']
    );
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    $tables = $pdo->query("SHOW TABLES")->fetchAll(PDO::FETCH_COLUMN);

    foreach ($tables as $table) {
        generateThentity($pdo, $table, $config);
    }

    echo "Les classes Thentity ont été générées avec succès.\n";
} catch (PDOException $e) {
    echo "Erreur de connexion : " . $e->getMessage() . "\n";
}
*/

class ThentityGenerator
{
    public array $config;
    public PDO $PDO;

    public function __construct(PDO $pdo, array $config)
    {
        $this->config = $config;
        $this->PDO = $pdo;

        return $this;
    }

    function generateThentityPropertyDoc(string $className): string
    {
        if (!method_exists($className, 'getTableKeys')) {
            return '';
        }

        $tableKeys = $className::getTableKeys();
        $properties = [];

        foreach ($tableKeys as $key => $details) {
            $type = $details['type'] ?? 'mixed'; // Par défaut, utilise 'mixed'
            $properties[] = "@property {$type} \${$key}";
        }

        return "/**\n * " . implode("\n * ", $properties) . "\n */";
    }

    function generateConfig()
    {
        $config = $this->config;
        // Namespace depuis config
        $nsConcrete = $config['namespace'];

        // Dossiers  config
        $dirConcrete = rtrim($config['output']['concrete_dir'], '/');

        // Crée le répertoire si nécessaire
        if (!is_dir($dirConcrete)) mkdir($dirConcrete, 0777, true);
        $filePathConcrete = "$dirConcrete/{$nsConcrete}Config.php";

        if (!file_exists($filePathConcrete)) {


            $db = $config['db'];
            $dsn = "mysql:host={$db['host']};dbname={$db['name']};charset={$db['charset']}";

            $contentClassConfig = "<?php\n\n";
            $contentClassConfig .= "namespace $nsConcrete;\n\n";
            $contentClassConfig .= "/**\n";
            $contentClassConfig .= " * Class {$nsConcrete}Config\n";
            $contentClassConfig .= " * This file is automatically generated only if it not exist. \n";
            $contentClassConfig .= " */\n\n";
            $contentClassConfig .= "class {$nsConcrete}Config\n{\n";
            $contentClassConfig .= "    public static function getPDOLink(): \\PDO\n";
            $contentClassConfig .= "    {\n";
            $contentClassConfig .= "        static \$pdo = null;\n";
            $contentClassConfig .= "        if (!\$pdo) {\n";
            $contentClassConfig .= "            try {\n";
            $contentClassConfig .= "                \$pdo = new \\PDO(\n";
            $contentClassConfig .= "                    '$dsn',\n";
            $contentClassConfig .= "                    '{$db['user']}',\n";
            $contentClassConfig .= "                    '{$db['pass']}',\n";
            $contentClassConfig .= "                    [\n";
            $contentClassConfig .= "                        \\PDO::ATTR_ERRMODE => \\PDO::ERRMODE_EXCEPTION,\n";
            $contentClassConfig .= "                        \\PDO::ATTR_DEFAULT_FETCH_MODE => \\PDO::FETCH_ASSOC\n";
            $contentClassConfig .= "                    ]\n";
            $contentClassConfig .= "                );\n";
            $contentClassConfig .= "            } catch (\\PDOException \$e) {\n";
            $contentClassConfig .= "                die('Erreur PDO: ' . \$e->getMessage());\n";
            $contentClassConfig .= "            }\n";
            $contentClassConfig .= "        }\n";
            $contentClassConfig .= "        return \$pdo;\n";
            $contentClassConfig .= "    }\n";
            $contentClassConfig .= "}\n";

            //$contentClassConfig .= "class $className extends $nsAbstract\\$className \n{\n }";
            file_put_contents($filePathConcrete, $contentClassConfig);
            echo "configuration générée dans $filePathConcrete  <br>\n";
        } else {
            echo "!! configuration existe déjà dans $filePathConcrete  <br>\n";
        }
    }

    /**
     * Génère une classe Thentity pour une table donnée.
     *
     * @param PDO $pdo
     * @param string $tableName
     */
    function generateThentity($tableName)
    {
        $config = $this->config;
        //$tableName = $this->config['db']['name'];
        $pdo = $this->PDO;
        // Récupération des informations détaillées sur les colonnes
        $columns = $pdo->query("DESCRIBE `$tableName`")->fetchAll(PDO::FETCH_ASSOC);

        // Récupération des informations sur les contraintes et les enum
        $columnDetails = $this->getColumnDetails($pdo, $tableName);

        $className = ucfirst($this->camelize($tableName));

        // Dossiers depuis config
        $dirAbstract = rtrim($config['output']['abstract_dir'], '/');
        $dirConcrete = rtrim($config['output']['concrete_dir'], '/');

        // Crée le répertoire si nécessaire
        if (!is_dir($dirAbstract)) mkdir($dirAbstract, 0777, true);
        if (!is_dir($dirConcrete)) mkdir($dirConcrete, 0777, true);

        $filePathAbstract = "$dirAbstract/$className.php";
        $filePathConcrete = "$dirConcrete/$className.php";

        if (!file_exists($filePathConcrete)) {
            // Namespace depuis config
            $nsConcrete = $config['namespace'];

            $phpContentConcrete = "<?php\n\n";
            $phpContentConcrete .= "namespace $nsConcrete;\n\n";
            $phpContentConcrete .= "/**\n";
            $phpContentConcrete .= " * Class $className\n";
            foreach ($columns as $column) {
                $columnConfig = $columnDetails[$column['Field']] ?? [];
                $phpType = $this->getPhpTypeFromConfig($columnConfig);
                $phpContentConcrete .= " * @property $phpType \${$column['Field']}\n";
            }
            $phpContentConcrete .= "*/\n";
            $phpContentConcrete .= "Class $className  extends \Thentity\\$className { \n";
            $phpContentConcrete .= "    public static function getPDOLink(): \\PDO\n    {\n";
            $phpContentConcrete .= "        return {$nsConcrete}Config::getPDOLink();\n";
            $phpContentConcrete .= "    }\n\n";
            $phpContentConcrete .= "}\n";

            //$phpContentConcrete .= "class $className extends $nsAbstract\\$className \n{\n }";
            file_put_contents($filePathConcrete, $phpContentConcrete);
            echo "Classe $className générée dans $filePathConcrete  <br>\n";
        } else {
            echo "!! Classe $className existe déjà dans $filePathConcrete  <br>\n";
        }

        // Génération du contenu PHP
        $phpContent = "<?php\n\n";
        $phpContent .= "namespace Thentity;\n\n";
        $phpContent .= "/**\n";
        $phpContent .= " * Abstract Class $className\n";
        $phpContent .= " * WARNING: This file is automatically generated by Thentity. \n";
        $phpContent .= " * Any manual changes will be overwritten. Do NOT edit this file manually!\n";
        foreach ($columns as $column) {
            $columnConfig = $columnDetails[$column['Field']] ?? [];
            $phpType = $this->getPhpTypeFromConfig($columnConfig);
            $phpContent .= " * @property $phpType \${$column['Field']}\n";
        }
        $phpContent .= " */\n";
        $phpContent .= "#[\AllowDynamicProperties]\n";
        $phpContent .= "abstract class $className extends \\Thentity\\ThentityAbstract\n{\n";
        $phpContent .= "    public static function getPrimaryKey(): string\n    {\n";
        $phpContent .= "        return '" . $this->getPrimaryKey($columns) . "';\n";
        $phpContent .= "    }\n\n";
        $phpContent .= "    public static function getTableKeys(): array\n    {\n";
        $phpContent .= "        return [\n";

        foreach ($columns as $column) {
            $columnConfig = $columnDetails[$column['Field']] ?? [];
            $phpContent .= $this->generateColumnConfig($column, $columnConfig);
        }

        $phpContent .= "        ];\n    }\n\n";
        $phpContent .= "    public static function getTableName(): string\n    {\n";
        $phpContent .= "        return '$tableName';\n";
        $phpContent .= "    }\n\n";
        $phpContent .= "}\n";

        file_put_contents($filePathAbstract, $phpContent);

        echo "Classe $className générée dans $filePathAbstract  <br>\n";
    }

    /**
     * Récupère les détails des colonnes depuis INFORMATION_SCHEMA
     *
     * @param PDO $pdo
     * @param string $tableName
     * @return array
     */
    function getColumnDetails(PDO $pdo, string $tableName): array
    {
        $query = "
        SELECT 
            COLUMN_NAME,
            DATA_TYPE,
            COLUMN_TYPE,
            IS_NULLABLE,
            COLUMN_DEFAULT,
            COLUMN_KEY,
            EXTRA,
            CHARACTER_MAXIMUM_LENGTH,
            NUMERIC_PRECISION,
            NUMERIC_SCALE
        FROM INFORMATION_SCHEMA.COLUMNS 
        WHERE TABLE_SCHEMA = :database 
        AND TABLE_NAME = :table
        ORDER BY ORDINAL_POSITION
    ";

        $stmt = $pdo->prepare($query);
        $stmt->execute([
            ':database' =>  $this->config['db']['name'],
            ':table' => $tableName
        ]);

        $details = [];
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $details[$row['COLUMN_NAME']] = $row;
        }

        return $details;
    }

    /**
     * Génère la configuration pour une colonne
     *
     * @param array $column Information de base de la colonne
     * @param array $columnConfig Configuration détaillée de la colonne
     * @return string
     */
    function generateColumnConfig(array $column, array $columnConfig): string
    {
        $fieldName = $column['Field'];
        $config = [];

        // Type de base
        $data_type = $columnConfig['DATA_TYPE'] ?? $column['Type'];
        $baseType = $this->getBaseType($data_type);
        $config['data_type'] = $data_type;

        // Gestion des ENUM
        if (stripos($column['Type'], 'enum') === 0) {
            $config['type'] = 'enum';
            $enumValues = $this->extractEnumValues($column['Type']);
            if (!empty($enumValues)) {
                $config['values'] = $enumValues;
            }
        } else {
            $config['type'] = $baseType;
        }

        // Nullable
        if ($column['Null'] === 'NO') {
            $config['nullable'] = false;
        }

        // Valeur par défaut
        if ($column['Default'] !== null && $column['Default'] !== '') {
            $defaultValue = $column['Default'];

            // Conversion des valeurs par défaut selon le type
            if ($baseType === 'int' && is_numeric($defaultValue)) {
                $config['default'] = (int)$defaultValue;
            } elseif ($baseType === 'float' && is_numeric($defaultValue)) {
                $config['default'] = (float)$defaultValue;
            } elseif ($baseType === 'bool') {
                $config['default'] = in_array(strtolower($defaultValue), ['1', 'true', 'yes']);
            } else {
                $config['default'] = $defaultValue;
            }
        }

        // Champs obligatoires (NOT NULL sans DEFAULT et pas de AUTO_INCREMENT)
        if (
            $column['Null'] === 'NO' && $column['Default'] === null &&
            stripos($column['Extra'], 'auto_increment') === false &&
            $column['Key'] !== 'PRI'
        ) {
            $config['mandatory'] = true;
        }

        // Auto increment
        if (stripos($column['Extra'], 'auto_increment') !== false) {
            $config['auto_increment'] = true;
        }

        // Longueur maximale pour les champs texte
        if (isset($columnConfig['CHARACTER_MAXIMUM_LENGTH']) && $columnConfig['CHARACTER_MAXIMUM_LENGTH'] > 0) {
            $config['max_length'] = (int)$columnConfig['CHARACTER_MAXIMUM_LENGTH'];
        }

        // Précision pour les nombres décimaux
        if (isset($columnConfig['NUMERIC_PRECISION']) && $columnConfig['NUMERIC_PRECISION'] > 0) {
            $config['precision'] = (int)$columnConfig['NUMERIC_PRECISION'];
            if (isset($columnConfig['NUMERIC_SCALE']) && $columnConfig['NUMERIC_SCALE'] > 0) {
                $config['scale'] = (int)$columnConfig['NUMERIC_SCALE'];
            }
        }

        // Clé primaire
        if ($column['Key'] === 'PRI') {
            $config['primary_key'] = true;
        }

        // Index unique
        if ($column['Key'] === 'UNI') {
            $config['unique'] = true;
        }

        // Formatage de la sortie
        $configStr = "            '$fieldName' => [";

        foreach ($config as $key => $value) {
            $configStr .= "\n                '$key' => ";
            if (is_array($value)) {
                $configStr .= "['" . implode("', '", $value) . "']";
            } elseif (is_bool($value)) {
                $configStr .= $value ? 'true' : 'false';
            } elseif (is_int($value) || is_float($value)) {
                $configStr .= $value;
            } else {
                $configStr .= "'" . addslashes($value) . "'";
            }
            $configStr .= ',';
        }

        $configStr .= "\n            ],\n";

        return $configStr;
    }

    /**
     * Extrait les valeurs d'un champ ENUM
     *
     * @param string $enumType
     * @return array
     */
    function extractEnumValues(string $enumType): array
    {
        preg_match_all("/'([^']*)'/", $enumType, $matches);
        return $matches[1] ?? [];
    }

    /**
     * Obtient le type PHP à partir de la configuration
     *
     * @param array $config
     * @return string
     */
    function getPhpTypeFromConfig(array $config): string
    {
        if (empty($config)) {
            return 'mixed';
        }

        $type = $config['DATA_TYPE'] ?? '';

        // Gestion spéciale pour les ENUM
        if (stripos($config['COLUMN_TYPE'] ?? '', 'enum') === 0) {
            return 'string';
        }

        return $this->mapColumnType($type);
    }

    /**
     * Obtient le type de base à partir du type SQL
     *
     * @param string $sqlType
     * @return string
     */
    function getBaseType(string $sqlType): string
    {
        $type = strtolower(preg_replace('/\(.*/', '', $sqlType));

        switch ($type) {
            case 'tinyint':
                // TINYINT(1) est souvent utilisé pour les booléens
                if (stripos($sqlType, 'tinyint(1)') !== false) {
                    return 'bool';
                }
                return 'int';
            case 'int':
            case 'smallint':
            case 'mediumint':
            case 'bigint':
                return 'int';
            case 'decimal':
            case 'numeric':
            case 'float':
            case 'double':
                return 'float';
            case 'char':
            case 'varchar':
            case 'text':
            case 'tinytext':
            case 'mediumtext':
            case 'longtext':
                return 'string';
            case 'blob':
            case 'tinyblob':
            case 'mediumblob':
            case 'longblob':
            case 'binary':
            case 'varbinary':
                return 'string';
            case 'date':
            case 'datetime':
            case 'timestamp':
            case 'time':
            case 'year':
                return 'string';
            case 'json':
                return 'array';
            case 'enum':
                return 'enum';
            case 'set':
                return 'array';
            default:
                return 'mixed';
        }
    }

    /**
     * Mappe les types SQL aux types PHP (version simplifiée pour rétrocompatibilité).
     *
     * @param string $sqlType
     * @return string
     */
    function mapColumnType(string $sqlType)
    {
        return $this->getBaseType($sqlType);
    }

    /**
     * Trouve la clé primaire dans la description de la table.
     *
     * @param array $columns
     * @return string
     */
    function getPrimaryKey(array $columns)
    {
        foreach ($columns as $column) {
            if ($column['Key'] === 'PRI') {
                return $column['Field'];
            }
        }
        return 'id'; // Valeur par défaut si aucune clé primaire n'est définie
    }

    /**
     * Convertit un nom de table en style camelCase.
     *
     * @param string $input
     * @return string
     */
    function camelize(string $input)
    {
        return str_replace(' ', '', ucwords(str_replace('_', ' ', $input)));
    }
}
